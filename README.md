##
Сервис производит получение данных с API мосбиржи в заданном временном интервале


#### Общая идея
Наша цель – создать окружение вокруг одного основного сервиса с минимальной логической нагрузкой.
Простенький* сервис c полноценной обвязкой.


> \* c т.з бизнес логики.
Для дипломного проекта вам потребуется написать несколько сервисов. Поэтому это задание – хорошая возможность начать разработку одного из них. Вы можете считать это первым шагом к дипломной работе. И, самое главное, вы сейчас думаете о инфре, а потом только о логике(именно поэтому в больших компаниях есть платформенные команды). Ибо одновременно обо всем думать - гоняться на 2мя зайцами


- Делаем упор на архитектуру приложения(модульность) и обвязку вокруг него. Логику сервиса оставляем на десерт(т.е API чата c 20ю ручками и паданием с паникой и без логов это ~~не сдал~~ фаталити)
- Описываем документацию для вашего API(swagger). Было б очень классно иметь схемки/диаграммы(PlantUML)
- Протоколы и интеграции: grpc/http/graphql/socket/etc. - на выбор
- Конфигурация env/yaml
- Рейтлимиты/троттлинг. Пока в самом сервисе, просто для понимания устройства
- HealthCheck
- Логирование запросов и ответов(а можно ли автоматизировать?)
- Обработка ошибок и паник(хендлинг разных типов)
- Авторизация и аутентификация
- Валидация входящих данных
- Подключаем систему сбора метрик, чтобы можно было мониторить наши сервисы. Думаем и описываем список необходимых технических/бизнесовых метрик
- Реализуем трейсинг, чтобы отслеживать запросы через все сервисы и вовремя выявлять проблемы
- smth else?

## Схемы сервиса
```plantuml
@startuml

actor "admin" as actor

component "API gateway" as gateway {
agent "REST" as rest
}

actor <---> rest


component "Внутринние сервисы" as internal {
agent "Слежение за котировками" as tracker
agent "Обработка данных" as storage
agent "Рассылка уведомлений" as notification
agent "Сбор данных" as parser


queue rabbitMQ {
queue "сырые данные" as rabbit_data {

}
queue "задания на рассылку" as rabbit_notifications

}


database database [
<b>Postgres
====
Котировки
----
Справочник эмитентов
----
Отчетность
----
Цели пользователей
----
Пользователи

]
}


cloud {
component "API Мосбиржи" as market
}

cloud {
agent "телеграмм пользователей" as telegramm
}

cloud {
agent "Отчетность компаний" as externalData
}

parser<--externalData : Парсинг
tracker-->storage : gRPC



parser-[thickness=4]->rabbit_data
rabbit_data-[thickness=4]->storage
storage-[thickness=4]->rabbit_notifications
rabbit_notifications-[thickness=4]->notification

market--->tracker : "Запрос котировок"

notification-->telegramm

rest <---> storage



storage<->database
@enduml
```

### Сборк
Перед сборкой контейнеров поднимаем общую сеть
```
docker network create fin-network
```